/******************************************************************************/
/**  COPYRIGHT (C) 2008 PMC-SIERRA, INC. ALL RIGHTS RESERVED.                **/
/**--------------------------------------------------------------------------**/
/** This software embodies materials and concepts which are proprietary and  **/
/** confidential to PMC-Sierra, Inc. PMC-Sierra distributes this software    **/
/** to its customers pursuant to the terms and conditions of the Software    **/
/** License Agreement contained in the text file software.lic that is        **/
/** distributed along with the software. This software can only be utilized  **/
/** if all terms and conditions of the Software License Agreement are        **/
/** accepted. If there are any questions, concerns, or if the                **/
/** Software License Agreement text file, software.lic, is missing please    **/
/** contact PMC-Sierra for assistance.                                       **/
/**--------------------------------------------------------------------------**/
/**                                                                          **/
/******************************************************************************/
/*******************************************************************************
**
**  MODULE      : HyPHY 20G Configuration Code
**
**  FILE        : hyphy20g_lsci_features.c
**
**  $Date: 2013-01-17 19:35:54 +0800 (Thu, 17 Jan 2013) $
**
**  $Revision: 30563 $
**
**  DESCRIPTION :
**
**
**  NOTES       :
**
*******************************************************************************/

/** include files **/
#include "hyphy20g_api_wrapper.h"
#include "hyphy20g_lsci_features.h"

/** external functions **/
extern INT4 lsciHyPhy20gLsciFcCbrUsrPattCfg(struct file *fileHndl, UINT4 slice,
                                     UINT4 dir, UINT4 olSeqHi, UINT4 olSeqLow,
                                     UINT4 pattDisp);

extern INT4 lsciHyPhy20gLsciCbrDataPathCfg(struct file *fileHndl, UINT4 slice);

/** external data **/

/** public data **/

/** private data **/

/******************************************************************************/
/* PRIVATE FUNCTION PROTOTYPES                                                */
/******************************************************************************/

/******************************************************************************/
/* PUBLIC FUNCTIONS                                                           */
/******************************************************************************/
/*******************************************************************************
**
**  hyPhy20gLsciFeGePauseFrmCfg
**  ___________________________________________________________________________
**
**  DESCRIPTION:    This function configures PAUSE TIME and Pause Frame
**                  Interval in the TMAC block.
**
**                  The PAUSE TIME setting determines the 2 octets 'PAUSE_TIME'
**                  field in the outgoing MAC Pause Frames generated by TMAC.
**                  Refer to IEEE 802.3 for the MAC Pause Frame Format.
**                  If the far-end receiving station processes PAUSE flow
**                  control, it should inhibit data frame transmission for the
**                  length of time specificed by the received 'PAUSE_TIME'
**                  value.
**
**                  The Pause Frame Interval setting determines the time
**                  interval between 2 MAC PAUSE frames transmissions
**                  in the TMAC block.
**
**                  Both PAUSE TIME and Pause Frame Interval are measured
**                  in units of pause_quanta. Refer to IEEE 802.3 for
**                  pause_quanta details.
**
**                  Used for MAC Terminated (FE/GE, SGMII FE/GE) mode only.
**
**                  This function must be called after hyPhy20gLsciInit.
**
**                  The default values provided in this description are
**                  relative to the state of the device after calling
**                  hyPhy20gLsciInit.
**
**                  This function can optionally be called after
**                  hyPhy20gLsciDataPathEnable.
**
**
**  INPUTS:         fileHndl  - device handle
**                  slice     - LSCI slice processing resource
**                              slice number 0 - 15
**                  pauseTime - see function description
**                              Legal range 0x0001 to 0xFFFF
**                              Default setting 0xFFFF
**                  pauseInt  - see function description
**                              Legal range 0x0001 to 0xFFFF
**                              Default setting 0xEFFF
**
**  OUTPUTS:        None       - None
**
**  RETURNS:        HYPHY20G_ERR_INCOMPATIBLE_DEVICE
**                  HYPHY20G_ERR_INVALID_ARG
**                  HYPHY20G_ERR_DEV_ACCESS
**                  HYPHY20G_SUCCESS
**
*******************************************************************************/
INT4 hyPhy20gLsciFeGePauseFrmCfg(struct file *fileHndl, UINT4 slice,
                                 UINT4 pauseTime, UINT4 pauseInt)
{
    INT4 result;
    UINT4 addr, msk;
    UINT4 devId, revId, status;
	
    /* Return error if API called against META device */
    result = hyPhy20gCheckRealRev(fileHndl, &devId, &revId, &status);
    if(result) return result;

    if (devId == HYPHY20G_META20G_DEVICE)
        return(HYPHY20G_ERR_INCOMPATIBLE_DEVICE);

    /* argument checking */
    if (slice > HYPHY20G_LSCI_NUM_SLICE - 1 ||
        pauseTime < 0x0001                  ||
        pauseTime > 0xFFFF                  ||
        pauseInt < 0x0001                   ||
        pauseInt > 0xFFFF) {
        return HYPHY20G_ERR_INVALID_ARG;
    }

    addr = HYPHY20G_LSCI_ENET_FEGE_TMAC_REG_PAUSE_FRM_TM_CFG;
    addr = HYPHY20G_LSCI_MTSB_SLICE_REG_OFFSET(addr, slice);
    msk  = HYPHY20G_LSCI_ENET_FEGE_TMAC_BIT_PAUSE_FRM_TM_CFG_PAUSE_TIME_MSK;
    result = hyPhy20gRegFieldWrite(fileHndl, addr, msk, pauseTime);
    if(result) return result;

    addr = HYPHY20G_LSCI_ENET_FEGE_TMAC_REG_PAUSE_FRM_INTRVL_CFG;
    addr = HYPHY20G_LSCI_MTSB_SLICE_REG_OFFSET(addr, slice);
    msk  = HYPHY20G_LSCI_ENET_FEGE_TMAC_BIT_PAUSE_FRM_INTRVL_CFG_PAUSE_IVAL_MSK;
    result = hyPhy20gRegFieldWrite(fileHndl, addr, msk, pauseInt);
    if(result) return result;

    return HYPHY20G_SUCCESS;

} /* hyPhy20gLsciFeGePauseFrmCfg */

/*******************************************************************************
**
**  hyPhy20gLsciFeGeSendFefi
**  ___________________________________________________________________________
**
**  DESCRIPTION:    This function can force sending FEFI.  The configuration is
**                  applied to the L1TPP block.
**
**                  Used for MAC Terminated FE mode only.
**
**                  When the receiver port is in LOS and the link is not
**                  configured for uni-directional operation (the bit 3 in
**                  register 0x4884000, unidirectional_mode is b'0), the L1TPP
**                  block sends FEF without software intervention.
**                  For rest of cases, this function may be called to
**                  enable or disable FEFI after a channel has been enabled.
**
**                  The FEF_GEN_EN field is accessed by FW when WAN to LAN
**                  consequential actions are enabled.  When FW WAN to LAN
**                  consequential actioon is enabled, this API should not be
**                  used, as it will not be reliable.
**
**  INPUTS:         fileHndl  - device handle
**                  slice     - LSCI slice processing resource
**                              slice number 0 - 15
**                  fefiEn
**                              0 - normal frame transmission
**                              1 - send FEFI indication instead of normal frame
**
**  OUTPUTS:        None      - None
**
**  RETURNS:        HYPHY20G_ERR_INCOMPATIBLE_DEVICE
**                  HYPHY20G_ERR_INVALID_ARG
**                  HYPHY20G_ERR_DEV_ACCESS
**                  HYPHY20G_SUCCESS
**
*******************************************************************************/
INT4 hyPhy20gLsciFeGeSendFefi(struct file *fileHndl, UINT4 slice, UINT4 fefiEn)
{
    INT4 result;
    UINT4 addr;
    UINT4 devId, revId, status;
	
    /* Return error if API called against META device */
    result = hyPhy20gCheckRealRev(fileHndl, &devId, &revId, &status);
    if(result) return result;

    if (devId == HYPHY20G_META20G_DEVICE)
        return(HYPHY20G_ERR_INCOMPATIBLE_DEVICE);

    /* argument checking */
    if (slice > HYPHY20G_LSCI_NUM_SLICE - 1 || fefiEn > 1) {
        return HYPHY20G_ERR_INVALID_ARG;
    }

    addr = HYPHY20G_LSCI_MTSB_SLICE_REG_OFFSET(HYPHY20G_LSCI_ENET_FEGE_L1TPP_REG_CTL,
                                               slice);
    result = sysHyPhy20gBitWrite(fileHndl, addr,
                HYPHY20G_LSCI_ENET_FEGE_L1TPP_BIT_CTL_FEF_GEN_EN_OFF, fefiEn);
    if(result) return result;

    return HYPHY20G_SUCCESS;
} /* hyPhy20gLsciFeGeSendFefi */

/*******************************************************************************
**
**  hyPhy20gLsciGeGfpTPattCfg
**  ___________________________________________________________________________
**
**  DESCRIPTION:    This function enable/disable a specific type of pattern
**                  function for error replacment.
**
**                  By default when calling hyPhy20gInit 10 bit and 20 bit
**                  patterns are configured to be standards compliant.  This
**                  function allows for variation from the standards based
**                  requirements.
**
**                  10 bit patterns replace errored code words.  20 bit patterns
**                  overwrite the data stream in the event of LOS.
**
**                  For enable operation, this funciton will set
**                  a specific type of pattern value and make the
**                  new configured pattern value take effect.
**
**                  Used for GE GFP-T mode.
**
**  INPUTS:         fileHndl  - device handle
**                  slice     - LSCI slice processing resource
**                              slice number 0 - 15
**                  type      - determine which pattern to be configured
**                              in GE_GFPT block
**                              0 - Rx 10-bit Pattern
**                              1 - Tx 10-bit Pattern
**                              2 - Rx 20-bit Pattern
**                              3 - Tx 20-bit Pattern
**                  pattern   - determine the pattern value
**                              0x0 -   0x3FF (type == 0 or 1)
**                              0x0 - 0xFFFFF (type == 2 or 3)
**                              set to 0 when pattEn == 0
**                  pattEn    - enable/disable error replacement using
**                              user configurable pattern
**                              0 - disable
**                              1 - enable
**
**  OUTPUTS:        None      - None
**
**  RETURNS:        HYPHY20G_ERR_INCOMPATIBLE_DEVICE
**                  HYPHY20G_ERR_INVALID_ARG
**                  HYPHY20G_ERR_DEV_ACCESS
**                  HYPHY20G_SUCCESS
**                  HYPHY20G_ERR_POLL_TIMEOUT
**
*******************************************************************************/
INT4 hyPhy20gLsciGeGfpTPattCfg(struct file *fileHndl, UINT4 slice, UINT4 type,
                               UINT4 pattern, UINT4 pattEn)
{
    INT4 result;
    UINT4 addr, enOff;
    UINT4 devId, revId, status;
	
    /* Return error if API called against META device */
    result = hyPhy20gCheckRealRev(fileHndl, &devId, &revId, &status);
    if(result) return result;

    if (devId == HYPHY20G_META20G_DEVICE)
        return(HYPHY20G_ERR_INCOMPATIBLE_DEVICE);

    /* argument checking */
    if (slice > HYPHY20G_LSCI_NUM_SLICE - 1 || type > 3 || pattEn > 1 ||
        (type < 2 && pattern > 0x3FF) ||
        (type > 1 && pattern > 0xFFFFF)) {
        return HYPHY20G_ERR_INVALID_ARG;
    }

    switch (type) {
        /* 0 - Rx 10-bit Pattern */
        case 0:
            addr    = HYPHY20G_LSCI_ENET_FEGE_GE_GFPT_REG_RX_CFG;
            enOff   = HYPHY20G_LSCI_ENET_FEGE_GE_GFPT_BIT_RX_CFG_RX_10BIT_PATT_EN_OFF;
            break;
        /* 1 - Tx 10-bit Pattern */
        case 1:
            addr    = HYPHY20G_LSCI_ENET_FEGE_GE_GFPT_REG_TX_CFG;
            enOff   = HYPHY20G_LSCI_ENET_FEGE_GE_GFPT_BIT_TX_CFG_TX_10BIT_PATT_EN_OFF;
            break;
        /* 2 - Rx 20-bit Pattern */
        case 2:
            addr    = HYPHY20G_LSCI_ENET_FEGE_GE_GFPT_REG_RX_20_BIT_PAT;
            enOff   = HYPHY20G_LSCI_ENET_FEGE_GE_GFPT_BIT_RX_20_BIT_PAT_RX_20BIT_PATT_EN_OFF;
            break;
        /* 3 - Tx 20-bit Pattern */
        case 3:
            addr    = HYPHY20G_LSCI_ENET_FEGE_GE_GFPT_REG_TX_20_BIT_PAT;
            enOff   = HYPHY20G_LSCI_ENET_FEGE_GE_GFPT_BIT_TX_20_BIT_PAT_TX_20BIT_PATT_EN_OFF;
            break;
        default:
            return HYPHY20G_ERR_INVALID_ARG;
    }

    addr = HYPHY20G_LSCI_MTSB_SLICE_REG_OFFSET(addr, slice);

    /* enable or disable pattern substitution feature */
    result = sysHyPhy20gBitWrite(fileHndl, addr, enOff, pattEn);
    if(result) return result;

    if (pattEn == 0) {
        return HYPHY20G_SUCCESS;
    }

    result = lsciHyPhy20gLsciGeGfpTPattUpdate(fileHndl, slice, type, pattern);
    if(result) return result;
        
    return HYPHY20G_SUCCESS;

} /* hyPhy20gLsciGeGfpTPattCfg */


/*******************************************************************************
**
**  hyPhy20gLsciGeGfpTSofPattDetectCfg
**  ___________________________________________________________________________
**
**  DESCRIPTION:  It is a SW workaround for the FC_CBR block and its SOF pattern
**                detector in the Rx and Tx directions in order to recognize
**                ethernet SOF indications. FW needs to be configured in FC/CBR
**                mode instead of ENET mode by function 
**                hyPhy20gHostMsgCmdCfgLedSetMonCtrl to support link activity 
**                of transparent GE clients.
**
**
**  INPUTS:       *fileHndl     - base address
**                 slice        - LSCI slice processing resource
**                                slice number 0 - 15
**                 enable       - 
**                                0 - restore the default value
**                                1 - normal operation
**  OUTPUTS:        None.
**
**  RETURNS:        HYPHY20G_ERR_INCOMPATIBLE_DEVICE
**                  HYPHY20G_ERR_INVALID_ARG
**                  HYPHY20G_ERR_NULL_PTR_PASSED
**                  HYPHY20G_ERR_INVALID_MODE
**                  HYPHY20G_ERR_INVALID_PRECONFIG
**                  HYPHY20G_ERR_DEV_ACCESS
**                  HYPHY20G_SUCCESS
**
*******************************************************************************/
INT4 hyPhy20gLsciGeGfpTSofPattDetectCfg(struct file *fileHndl,UINT4 slice,UINT4 enable)
{
    INT4 result;
    UINT4 regCfgAddr;
    UINT4 devId, revId, status, regVal;
    UINT4 Reg_SOF_PATT,Reg_SOF_PATT_EN;

    /* argument checking */
    if (slice > HYPHY20G_LSCI_NUM_SLICE - 1 || enable > 1) {
        return HYPHY20G_ERR_INVALID_ARG;
    }   
    
    /* Return error if API called against META device */
    result = hyPhy20gCheckRealRev(fileHndl, &devId, &revId, &status);
    if(result) return result;

    if (devId == HYPHY20G_META20G_DEVICE)
        return(HYPHY20G_ERR_INCOMPATIBLE_DEVICE);

    /* argument checking */
    if (slice > HYPHY20G_LSCI_NUM_SLICE - 1) {
        return HYPHY20G_ERR_INVALID_ARG;
    }

    regCfgAddr = HYPHY20G_LSCI_TOP_REG_CFG + 0x08000*slice;
    result = sysHyPhy20gRead(fileHndl,regCfgAddr,&regVal);
    if(result) return result;

    if(enable)
    {
        regVal &= (~HYPHY20G_LSCI_TOP_BIT_CFG_PMM_LOWPWR_MSK);
        regVal &= (~HYPHY20G_LSCI_TOP_BIT_CFG_FC_CBR_LOWPWR_MSK);
        regVal &= (~HYPHY20G_LSCI_TOP_BIT_CFG_ENET_FEGE_LOWPWR_MSK);
        regVal &= (~HYPHY20G_LSCI_TOP_BIT_CFG_PMM_RST_MSK);
        regVal &= (~HYPHY20G_LSCI_TOP_BIT_CFG_FC_CBR_RST_MSK);
        regVal &= (~HYPHY20G_LSCI_TOP_BIT_CFG_ENET_FEGE_RST_MSK);
        regVal &= (~HYPHY20G_LSCI_TOP_BIT_CFG_LSCI_RST_MSK);

        regVal |= (HYPHY20G_LSCI_TOP_BIT_CFG_REFCLK334_SEL_MSK);
        regVal |= (HYPHY20G_LSCI_TOP_BIT_CFG_ENET_MODE_SEL_MSK);
        regVal &= (~HYPHY20G_LSCI_TOP_BIT_CFG_PMM_MODE_SEL_MSK );
        regVal |= (HYPHY20G_LSCI_TOP_BIT_CFG_SYS_MODE_SEL_MSK );
        regVal &= (~HYPHY20G_LSCI_TOP_BIT_CFG_LINE_MODE_SEL_MSK);

        Reg_SOF_PATT = 0x00000368;
        Reg_SOF_PATT_EN = 0x0000000B;
    }else{

        Reg_SOF_PATT = 0x0; /* the default value */
        Reg_SOF_PATT_EN = 0x0; /* the default value */
    }

    regCfgAddr = HYPHY20G_LSCI_TOP_REG_CFG + 0x08000*slice;
    result = sysHyPhy20gWrite(fileHndl,regCfgAddr,regVal);
    if(result) return result;

    result = lsciHyPhy20gLsciCbrDataPathCfg(fileHndl,slice);
    if(result) return result;


    regCfgAddr = HYPHY20G_LSCI_MTSB_SLICE_REG_OFFSET(HYPHY20G_LSCI_FC_CBR_REG_CFG, slice);
    result = hyPhy20gRegFieldWrite(fileHndl, regCfgAddr,
                HYPHY20G_LSCI_FC_CBR_BIT_CFG_MODE_MSK, 1); /* 1: ESCON traffic */
    if(result) return result;

    result = hyPhy20gRegFieldWrite(fileHndl, regCfgAddr,
                HYPHY20G_LSCI_FC_CBR_BIT_CFG_MODE_MSK, 1);/* 1: CBR 8B/10B encoded traffic */
    if(result) return result;

    /* RX_SOF_PATT = 0x368   GE 10-bit K27.7 /S/ pattern*/
    regCfgAddr = 0x4886228 + 0x08000 * slice;
    result = sysHyPhy20gWrite(fileHndl, regCfgAddr, Reg_SOF_PATT);
    if(result) return result;

    /* RX_SOF_PATT_EN = 0x3  RX_SOF_IND_EN = 0x1 */
    regCfgAddr = 0x488622C + 0x08000 * slice;
    result = sysHyPhy20gWrite(fileHndl, regCfgAddr, Reg_SOF_PATT_EN); 
    if(result) return result;

    /* TX_SOF_PATT = 0x368; # GE 10-bit K27.7 /S/ pattern */
    regCfgAddr = 0x4886258 + 0x08000 * slice;
    result = sysHyPhy20gWrite(fileHndl, regCfgAddr, Reg_SOF_PATT);
    if(result) return result;

    /* TX_SOF_PATT_EN = 0x3 TX_SOF_IND_EN = 0x1*/
    regCfgAddr = 0x488625C + 0x08000 * slice;
    result = sysHyPhy20gWrite(fileHndl,regCfgAddr, Reg_SOF_PATT_EN);
    if(result) return result;

    regCfgAddr = HYPHY20G_LSCI_FC_CBR_REG_CFG + 0x08000 * slice;
    result = sysHyPhy20gBitWrite(fileHndl, regCfgAddr, HYPHY20G_LSCI_FC_CBR_BIT_CFG_SOFT_RST_OFF, 0);
    if(result) return result;

    return HYPHY20G_SUCCESS;
} /* end of hyPhy20gLsciGeGfpTSofPattDetectCfg*/

/*******************************************************************************
**
**  hyPhy20gLsciFcCbrPattForce
**  ___________________________________________________________________________
**
**  DESCRIPTION:  This function allows for 40-bit or 32-bit user-configured
**                pattern to overwrite data in the transmit or receive
**                stream for a LSCI slice operating in FC, ESCON or CBR mode.
**
**                When pattern forcing is disabled, in the receive direction,
**                user-configured pattern will be generated in response to
**                DLOLB events. In the transmit direction, user-configured
**                pattern will be generated if no data is being forwarded
**                from the CPB.
**
**                Note, changing the RX_NOS_PN11_SEL and
**                TX_NOS_PN11_SEL bits require RX_SOFT_RST or
**                TX_SOFT_RST assertion, which will disrupt the data stream.
**                So the RX_NOS_PN11_SEL and TX_NOS_PN11_SEL bits keep in b'0,
**                and should never be changed.
**
**                To insert NOS, the user-configured pattern
**                is used. Used for FC, ESCON or low-speed CBR modes.
**
**                For non 8b10b CBR clients this will generate the pattern as
**                configured with hyPhy20gLsciByteAlignedCbrUsrPattCfg.   This
**                provide the ability to generate PN-11 or a user 32-bit value.
**                This API will toggle the RX_NOS_PN11_SEL and TX_NOS_PN11_SEL
**                bits with the respective *_SOFT_RST bits.  In this case a
**                momentary hit to the data stream may occur.
**
**                This function can optionally be called after
**                hyPhy20gLsciDataPathEnable.
**
**  INPUTS:       *fileHndl     - base address
**                 slice        - LSCI slice processing resource
**                                slice number 0 - 15
**                 dir          - data flow direction
**                              0 - transmit data flow
**                                  from the CPB to the SFP
**                              1 - receive data flow
**                                  from the SFP to the CPB
**                 mode         - data stream overwriting operation
**                              0 - do not overwrite data stream
**                              1 - overwrite data stream with 40-bit or 32-bit
**                                  user-defined pattern
**
**  OUTPUTS:        None.
**
**  RETURNS:        HYPHY20G_ERR_INCOMPATIBLE_DEVICE
**                  HYPHY20G_ERR_INVALID_ARG
**                  HYPHY20G_ERR_NULL_PTR_PASSED
**                  HYPHY20G_ERR_INVALID_MODE
**                  HYPHY20G_ERR_INVALID_PRECONFIG
**                  HYPHY20G_ERR_DEV_ACCESS
**                  HYPHY20G_SUCCESS
**
*******************************************************************************/
INT4 hyPhy20gLsciFcCbrPattForce(struct file *fileHndl, UINT4 slice, UINT4 dir,
                                UINT4 mode)
{
    INT4 result;
    UINT4 traffic;
    UINT4 regCfgAddr, regCfgOffset;
    UINT4 devId, revId, status;
	
    /* Return error if API called against META device */
    result = hyPhy20gCheckRealRev(fileHndl, &devId, &revId, &status);
    if(result) return result;

    if (devId == HYPHY20G_META20G_DEVICE)
        return(HYPHY20G_ERR_INCOMPATIBLE_DEVICE);

    /* argument checking */
    if (slice > HYPHY20G_LSCI_NUM_SLICE - 1 || dir > 1 || mode > 1) {
        return HYPHY20G_ERR_INVALID_ARG;
    }

    /* retrieve slice mode from context */
    result = lsciHyPhy20gLsciCtxtGetMode(fileHndl, slice, &traffic);
    if(result) return result;
    /* confirm mode before processing */
    if (traffic < LSCI_FC_4G || traffic > LSCI_8B10B_TX_RD_INV_DIS_CBR) {
        return HYPHY20G_ERR_INVALID_PRECONFIG;
    }

    switch (dir) {
        case HYPHY20G_TX_DIRECTION:
            regCfgAddr = HYPHY20G_LSCI_FC_CBR_REG_TX_CFG;
            regCfgOffset = HYPHY20G_LSCI_FC_CBR_BIT_TX_CFG_TX_FORCE_NOS_PN11_OFF;
            break;
        case HYPHY20G_RX_DIRECTION:
            regCfgAddr = HYPHY20G_LSCI_FC_CBR_REG_RX_CFG;
            regCfgOffset = HYPHY20G_LSCI_FC_CBR_BIT_RX_CFG_RX_FORCE_NOS_PN11_OFF;
            break;
        default:
            return HYPHY20G_ERR_INVALID_ARG;
    }

    /* enable/disable the FORCE_NOS_PN11 bit */
    regCfgAddr = HYPHY20G_LSCI_MTSB_SLICE_REG_OFFSET(regCfgAddr, slice);
    result = sysHyPhy20gBitWrite(fileHndl, regCfgAddr, regCfgOffset, mode);
    if(result) return result;

    return HYPHY20G_SUCCESS;

} /* hyPhy20gLsciFcCbrPattForce */



/*******************************************************************************
**
**  hyPhy20gLsciByteAlignedCbrUsrPattCfg
**  ___________________________________________________________________________
**
**  DESCRIPTION:  This function allows for a PN11 sequences or 32-bit
**                user-defined pattern to overwrite data in the transmit or
**                receive stream for a LSCI slice operating in
**                the byte-aligned CBR modes.
**
**                In the byte-aligned CBR modes, the running
**                disparity is not applicable.
**
**                The PN11 sequences or user-configured pattern will
**                overwrite user data when either when DLOLB condition is
**                detected or the pattern is manually enabled by
**                hyPhy20gLsciFcCbrPattForce API, for transmit and receive path
**                respectively.
**
**                The function hyPhy20gLsciFcCbrPattForce can be used to dynamically
**                have the ordered set (PN11 sequences or 32-bit
**                user-defined pattern) overwrite the user data stream.
**
**                This function may be called while pattern overwriting is
**                forced to dynamically change the user-defined pattern that is
**                overwriting the data stream. However, switching ordered set
**                between PN11 sequences and 32-bit user-defined pattern will
**                disrupt the user data stream.
**
**                This function must be called after hyPhy20gLsciInit.
**
**  INPUTS:       *fileHndl     - base address
**                 slice        - LSCI slice processing resource
**                                slice number 0 - 15
**                 dir          - data flow direction
**                                0 - transmit data flow
**                                    from the CPB to the SFP
**                                1 - receive data flow
**                                    from the SFP to the CPB
**                 mode         - data stream overwriting operation
**                                0 - overwrite data stream with 32-bit
**                                    user-defined pattern as specified
**                                    in userChar and userCharDisp arguments
**                                1 - overwrite data stream with PN11
**                 userChar     - Used for mode == 0
**                                Four user defined 10 bit characters
**                                each 10 bit character must be positive or
**                                negative disparity.
**                                Default value 0xAA954AA5
**
**  OUTPUTS:        None.
**
**  RETURNS:        HYPHY20G_ERR_INCOMPATIBLE_DEVICE
**                  HYPHY20G_ERR_INVALID_ARG
**                  HYPHY20G_ERR_NULL_PTR_PASSED
**                  HYPHY20G_ERR_INVALID_MODE
**                  HYPHY20G_ERR_INVALID_PRECONFIG
**                  HYPHY20G_ERR_DEV_ACCESS
**                  HYPHY20G_ERR_POLL_TIMEOUT
**                  HYPHY20G_SUCCESS
**
*******************************************************************************/
INT4 hyPhy20gLsciByteAlignedCbrUsrPattCfg(struct file *fileHndl, UINT4 slice,
                                          UINT4 dir, UINT4 mode, UINT4 userChar)
{
    INT4 result;
    UINT4 traffic;
    UINT4 regCfgAddr, selOffset, rstOffset;
    UINT4 selBitVal, rstBitVal;
    UINT4 olSeqHi, olSeqLow;
    UINT4 devId, revId, status;
	
    /* Return error if API called against META device */
    result = hyPhy20gCheckRealRev(fileHndl, &devId, &revId, &status);
    if(result) return result;

    if (devId == HYPHY20G_META20G_DEVICE)
        return(HYPHY20G_ERR_INCOMPATIBLE_DEVICE);

    /* argument checking */
    if (slice > HYPHY20G_LSCI_NUM_SLICE - 1 ||
        dir > 1 ||
        mode > 1) {
        return HYPHY20G_ERR_INVALID_ARG;
    }

    /* retrieve slice mode from context */
    result = lsciHyPhy20gLsciCtxtGetMode(fileHndl, slice, &traffic);
    if(result) return result;
    /* confirm mode before processing */
    if (traffic < LSCI_BYTEALIGED_CBR_STS || traffic > LSCI_BYTEALIGED_CBR) {
        return HYPHY20G_ERR_INVALID_PRECONFIG;
    }

    switch (dir) {
        case HYPHY20G_TX_DIRECTION:
            regCfgAddr = HYPHY20G_LSCI_FC_CBR_REG_TX_CFG;
            selOffset = HYPHY20G_LSCI_FC_CBR_BIT_TX_CFG_TX_NOS_PN11_SEL_OFF;
            rstOffset = HYPHY20G_LSCI_FC_CBR_BIT_TX_CFG_TX_SOFT_RST_OFF;
            break;
        case HYPHY20G_RX_DIRECTION:
            regCfgAddr = HYPHY20G_LSCI_FC_CBR_REG_RX_CFG;
            selOffset = HYPHY20G_LSCI_FC_CBR_BIT_RX_CFG_RX_NOS_PN11_SEL_OFF;
            rstOffset = HYPHY20G_LSCI_FC_CBR_BIT_RX_CFG_RX_SOFT_RST_OFF;
            break;
        default:
            return HYPHY20G_ERR_INVALID_ARG;
    }

    regCfgAddr = HYPHY20G_LSCI_MTSB_SLICE_REG_OFFSET(regCfgAddr, slice);
    result = sysHyPhy20gBitRead(fileHndl, regCfgAddr, selOffset, &selBitVal);
    if(result) return result;
    result = sysHyPhy20gBitRead(fileHndl, regCfgAddr, selOffset, &rstBitVal);
    if(result) return result;

    /* select PN-11 or user defined pattern */
    if (mode != selBitVal) {
        /* The TX_NOS_PN11_SEL and RX_NOS_PN11_SEL fields must be configured
           when the soft reset (SOFT_RST or TX_SOFT_RST/RX_SOFT_RST)
           is asserted. */
        if (!rstBitVal) {
            result = sysHyPhy20gBitWrite(fileHndl, regCfgAddr, rstOffset, 1);
            if(result) return result;
        }

        result = sysHyPhy20gBitWrite(fileHndl, regCfgAddr, selOffset, mode);
        if(result) return result;

        if (!rstBitVal) {
            result = sysHyPhy20gBitWrite(fileHndl, regCfgAddr, rstOffset, 0);
            if(result) return result;
        }
    }

    if (!mode) {
        /* write 32-bit user-defined pattern */
        olSeqHi     = 0x3E;
        olSeqLow    = userChar;
        result = lsciHyPhy20gLsciFcCbrUsrPattCfg(fileHndl, slice, dir,
                                                 olSeqHi, olSeqLow, 0);
        if(result) return result;
    }

    return HYPHY20G_SUCCESS;
} /* hyPhy20gLsciByteAlignedCbrUsrPattCfg */


/*******************************************************************************
**
**  hyPhy20gLsci8b10bCbrUsrPattCfg
**  ___________________________________________________________________________
**
**  DESCRIPTION:  This function configures the 4 user defined 10 bit
**                characters to overwrite data in the transmit or receive
**                stream for a LSCI slice operating in 8b10b CBR mode.
**
**                As 4 user defined 10 bit characters are specified, the
**                pattern must start with negative running disparity, and end
**                with negative running disparity. This function internally
**                set the negative running disparity for each 10-bit character.
**
**                The user-configured pattern will overwrite user
**                data when either DLOLB condition is detected or the
**                pattern is manually enabled by hyPhy20gLsciFcCbrPattForce API,
**                for transmit and receive path respectively.
**
**                The function hyPhy20gLsciFcCbrPattForce can be used to dynamically
**                have the user defined pattern overwrite the user data stream.
**
**                This function may be called while pattern overwriting is
**                forced to dynamically change the ordered set that is
**                overwriting the data stream.
**
**                This function must be called after hyPhy20gLsciInit.
**
**  INPUTS:       *fileHndl     - base address
**                 slice        - LSCI slice processing resource
**                                slice number 0 - 15
**                 dir          - data flow direction
**                                0 - transmit data flow
**                                    from the CPB to the SFP
**                                1 - receive data flow
**                                    from the SFP to the CPB
**                 userChar[4]  - Four user defined 10 bit characters
**                                each 10 bit character must be positive or
**                                negative disparity.
**                                Default value Escon OLS Sequence:
**                                userChar[3] = 0x0FA (K28.5)
**                                userChar[2] = 0x2A9 (D21.1)
**                                userChar[1] = 0x152 (D10.4)
**                                userChar[0] = 0x2A5 (D21.2) 
**                 userCharDisp - Used for mode == 0
**                                Disparity type for each user defined character
**                                set to 0 for negative disparity
**                                set to 1 for positive disparity
**                                bit3 - disparity for userChar[3]
**                                bit2 - disparity for userChar[2]
**                                bit1 - disparity for userChar[1]
**                                bit0 - disparity for userChar[0]
**                                Default value: 0xC
**
**  OUTPUTS:        None.
**
**  RETURNS:        HYPHY20G_ERR_INCOMPATIBLE_DEVICE
**                  HYPHY20G_ERR_INVALID_ARG
**                  HYPHY20G_ERR_NULL_PTR_PASSED
**                  HYPHY20G_ERR_INVALID_MODE
**                  HYPHY20G_ERR_INVALID_PRECONFIG
**                  HYPHY20G_ERR_DEV_ACCESS
**                  HYPHY20G_ERR_POLL_TIMEOUT
**                  HYPHY20G_SUCCESS
**
*******************************************************************************/
INT4 hyPhy20gLsci8b10bCbrUsrPattCfg(struct file *fileHndl, UINT4 slice,
                                    UINT4 dir, UINT4 userChar[4],
                                    UINT4 userCharDisp)
{
    INT4 result;
    UINT4 traffic;
    UINT4 olSeqHi, olSeqLow;
    UINT4 devId, revId, status;
	
    /* Return error if API called against META device */
    result = hyPhy20gCheckRealRev(fileHndl, &devId, &revId, &status);
    if(result) return result;

    if (devId == HYPHY20G_META20G_DEVICE)
        return(HYPHY20G_ERR_INCOMPATIBLE_DEVICE);

    /* argument checking */
    if (slice > HYPHY20G_LSCI_NUM_SLICE - 1 || dir > 1 || userCharDisp > 0xF) {
        return HYPHY20G_ERR_INVALID_ARG;
    }

    /* retrieve slice mode from context */
    result = lsciHyPhy20gLsciCtxtGetMode(fileHndl, slice, &traffic);
    if(result) return result;
    /* confirm mode before processing */
    if ((traffic != LSCI_8B10B_TX_RD_INV_EN_CBR) &&
        (traffic != LSCI_8B10B_TX_RD_INV_DIS_CBR)) {
        return HYPHY20G_ERR_INVALID_PRECONFIG;
    }

    /* select user defined pattern */
    olSeqHi     = ((userChar[3] & 0x03FC) >> 2);

    olSeqLow    = ((userChar[3] & 0x0003) << 30) | 
                  ((userChar[2] & 0x03FF) << 20) |
                  ((userChar[1] & 0x03FF) << 10) |
                  (userChar[0] & 0x03FF);
    result = lsciHyPhy20gLsciFcCbrUsrPattCfg(fileHndl, slice, dir,
                                             olSeqHi, olSeqLow, userCharDisp);
    if(result) return result;

    return HYPHY20G_SUCCESS;
} /* hyPhy20gLsci8b10bCbrUsrPattCfg */


/*******************************************************************************
**
**  hyPhy20gLsciFcUsrPattCfg
**  ___________________________________________________________________________
**
**  DESCRIPTION:  This function configures the 4 user defined 10 bit
**                characters to overwrite data in the transmit or receive
**                stream for a LSCI slice operating in FC mode.
**
**                Running disparity setting is not applicable
**                in ESCON and FC mode.
**
**                The user-configured pattern will overwrite user
**                data when either DLOLB condition is detected or the
**                pattern is manually enabled by hyPhy20gLsciFcCbrPattForce API,
**                for transmit and receive path respectively.
**
**                In the receive data stream this pattern will overwrite user
**                data in the event of RX_DLOLB condition.  In the transmit
**                path this data stream will be generated in the
**                event of TX_DLOLB condition.
**
**                The function hyPhy20gLsciFcCbrPattForce can be used to dynamically
**                have the user defined pattern overwrite the user data stream.
**
**                This function may be called while pattern overwriting is
**                forced to dynamically change the ordered set that is
**                overwriting the data stream.
**
**                This function must be called after hyPhy20gLsciInit.
**
**  INPUTS:       *fileHndl     - base address
**                 slice        - LSCI slice processing resource
**                                slice number 0 - 15
**                 dir          - data flow direction
**                                0 - transmit data flow
**                                    from the CPB to the SFP
**                                1 - receive data flow
**                                    from the SFP to the CPB
**                 userChar[4]  - Four user defined 10 bit characters
**                                each 10 bit character must be positive or
**                                negative disparity.
**                                Default value FC OLS Sequence:
**                                userChar[3] = 0x0FA (K28.5)
**                                userChar[2] = 0x2A9 (D21.1)
**                                userChar[1] = 0x152 (D10.4)
**                                userChar[0] = 0x2A5 (D21.2)
**                                The FC NOS Sequence:
**                                userChar[3] = 0x0FA (K28.5)
**                                userChar[2] = 0x2A5 (D21.2)
**                                userChar[1] = 0x14A (D31.5)
**                                userChar[0] = 0x295 (D05.2)
**
**  OUTPUTS:        None.
**
**  RETURNS:        HYPHY20G_ERR_INCOMPATIBLE_DEVICE
**                  HYPHY20G_ERR_INVALID_ARG
**                  HYPHY20G_ERR_NULL_PTR_PASSED
**                  HYPHY20G_ERR_INVALID_MODE
**                  HYPHY20G_ERR_INVALID_PRECONFIG
**                  HYPHY20G_ERR_DEV_ACCESS
**                  HYPHY20G_ERR_POLL_TIMEOUT
**                  HYPHY20G_SUCCESS
**
*******************************************************************************/
INT4 hyPhy20gLsciFcUsrPattCfg(struct file *fileHndl, UINT4 slice, UINT4 dir,
                              UINT4 userChar[4])
{
    INT4 result;
    UINT4 traffic;
    UINT4 olSeqHi, olSeqLow;
    UINT4 devId, revId, status;
	
    /* Return error if API called against META device */
    result = hyPhy20gCheckRealRev(fileHndl, &devId, &revId, &status);
    if(result) return result;

    if (devId == HYPHY20G_META20G_DEVICE)
        return(HYPHY20G_ERR_INCOMPATIBLE_DEVICE);

    /* argument checking */
    if (slice > HYPHY20G_LSCI_NUM_SLICE - 1 || dir > 1) {
        return HYPHY20G_ERR_INVALID_ARG;
    }

    /* retrieve slice mode from context */
    result = lsciHyPhy20gLsciCtxtGetMode(fileHndl, slice, &traffic);
    if(result) return result;
    /* confirm mode before processing */
    if (traffic != LSCI_FC_4G) {
        return HYPHY20G_ERR_INVALID_PRECONFIG;
    }

    /* select user defined pattern */
    olSeqHi     = ((userChar[3] & 0x03FC) >> 2);

    olSeqLow    = ((userChar[3] & 0x0003) << 30) | 
                  ((userChar[2] & 0x03FF) << 20) |
                  ((userChar[1] & 0x03FF) << 10) |
                  (userChar[0] & 0x03FF);
    /* running disparity is not used for FC mode, set to 0 */
    result = lsciHyPhy20gLsciFcCbrUsrPattCfg(fileHndl, slice, dir,
                                             olSeqHi, olSeqLow, 0);
    if(result) return result;

    return HYPHY20G_SUCCESS;
} /* hyPhy20gLsciFcUsrPattCfg */



/*******************************************************************************
**
**  hyPhy20gLsciEsconUsrPattCfg
**  ___________________________________________________________________________
**
**  DESCRIPTION:  This function configures the 4 user defined 10 bit
**                characters to overwrite data in the transmit or receive
**                stream for a LSCI slice operating in Escon mode.
**
**                Running disparity setting is not applicable
**                in ESCON and FC mode.
**
**                The user-configured pattern will overwrite user
**                data when either DLOLB condition is detected or the
**                pattern is manually enabled by hyPhy20gLsciFcCbrPattForce API,
**                for transmit and receive path respectively.
**
**                In the receive data stream this pattern will overwrite user
**                data in the event of RX_DLOLB condition. In the transmit
**                path this data stream will be generated in the
**                event of TX_DLOLB condition.
**
**                The function hyPhy20gLsciFcCbrPattForce can be used to dynamically
**                have the user defined pattern overwrite the user data stream.
**
**                This function may be called while pattern overwriting is
**                forced to dynamically change the ordered set that is
**                overwriting the data stream.
**
**                This function must be called after hyPhy20gLsciInit.
**
**  INPUTS:       *fileHndl     - base address
**                 slice        - LSCI slice processing resource
**                                slice number 0 - 15
**                 dir          - data flow direction
**                                0 - transmit data flow
**                                    from the CPB to the SFP
**                                1 - receive data flow
**                                    from the SFP to the CPB
**                 userChar[4]  - Four user defined 10 bit characters
**                                each 10 bit character must be positive or
**                                negative disparity.
**                                Default value FC OLS Sequence:
**                                userChar[3] = 0x0FA (K28.5)
**                                userChar[2] = 0x2A9 (D21.1)
**                                userChar[1] = 0x152 (D10.4)
**                                userChar[0] = 0x2A5 (D21.2)
**                                The FC NOS Sequence:
**                                userChar[3] = 0x0FA (K28.5)
**                                userChar[2] = 0x2A5 (D21.2)
**                                userChar[1] = 0x14A (D31.5)
**                                userChar[0] = 0x295 (D05.2)
**
**
**  OUTPUTS:        None.
**
**  RETURNS:        HYPHY20G_ERR_INCOMPATIBLE_DEVICE
**                  HYPHY20G_ERR_INVALID_ARG
**                  HYPHY20G_ERR_NULL_PTR_PASSED
**                  HYPHY20G_ERR_INVALID_MODE
**                  HYPHY20G_ERR_INVALID_PRECONFIG
**                  HYPHY20G_ERR_DEV_ACCESS
**                  HYPHY20G_ERR_POLL_TIMEOUT
**                  HYPHY20G_SUCCESS
**
*******************************************************************************/
INT4 hyPhy20gLsciEsconUsrPattCfg(struct file *fileHndl, UINT4 slice, UINT4 dir,
                                 UINT4 userChar[4])
{
    INT4 result;
    UINT4 traffic;
    UINT4 olSeqHi, olSeqLow;
    UINT4 devId, revId, status;
	
    /* Return error if API called against META device */
    result = hyPhy20gCheckRealRev(fileHndl, &devId, &revId, &status);
    if(result) return result;

    if (devId == HYPHY20G_META20G_DEVICE)
        return(HYPHY20G_ERR_INCOMPATIBLE_DEVICE);

    /* argument checking */
    if (slice > HYPHY20G_LSCI_NUM_SLICE - 1 || dir > 1) {
        return HYPHY20G_ERR_INVALID_ARG;
    }

    /* retrieve slice mode from context */
    result = lsciHyPhy20gLsciCtxtGetMode(fileHndl, slice, &traffic);
    if(result) return result;
    /* confirm mode before processing */
    if (traffic != LSCI_ESCON) {
        return HYPHY20G_ERR_INVALID_PRECONFIG;
    }

    /* select user defined pattern */
    olSeqHi     = ((userChar[3] & 0x03FC) >> 2);

    olSeqLow    = ((userChar[3] & 0x0003) << 30) |
                  ((userChar[2] & 0x03FF) << 20) |
                  ((userChar[1] & 0x03FF) << 10) |
                  (userChar[0] & 0x03FF);
    /* userCharDisp is not used for FC mode, set to 0 */
    result = lsciHyPhy20gLsciFcCbrUsrPattCfg(fileHndl, slice, dir,
                                             olSeqHi, olSeqLow, 0);
    if(result) return result;

    return HYPHY20G_SUCCESS;
} /* hyPhy20gLsciEsconUsrPattCfg */


/*******************************************************************************
**
**  hyPhy20gLsciGeReAutoNeg
**  ___________________________________________________________________________
**
**  DESCRIPTION:    This function will restart Auto-Negotiation state machine
**                  and will make the device begin the Auto-Negotiation
**                  process again.
**
**                  It is user's responsibility to ensure this function is only
**                  used in GE MAC Terminated mode and auto-negotiation is
**                  enabled.
**
**                  Calling this function will interrupt the data flow in case
**                  of the data flow is previously enabled.
**
**  INPUTS:         fileHndl  - device handle
**                  slice     - LSCI slice processing resource
**                              slice number 0 - 15
**
**  OUTPUTS:        None      - None
**
**  RETURNS:        HYPHY20G_ERR_INCOMPATIBLE_DEVICE
**                  HYPHY20G_ERR_INVALID_ARG
**                  HYPHY20G_ERR_DEV_ACCESS
**                  HYPHY20G_ERR_INVALID_PRECONFIG
**                  HYPHY20G_ERR_POLL_TIMEOUT
**                  HYPHY20G_SUCCESS
**
*******************************************************************************/
INT4 hyPhy20gLsciGeReAutoNeg(struct file *fileHndl, UINT4 slice)
{
    INT4 result;
    UINT4 addr;
    UINT4 anEnblOff;
    UINT4 anEnblVal;
    UINT4 anRstOff;
    UINT4 anRstMsk;
    UINT4 devId, revId, status;
	
    /* Return error if API called against META device */
    result = hyPhy20gCheckRealRev(fileHndl, &devId, &revId, &status);
    if(result) return result;

    if (devId == HYPHY20G_META20G_DEVICE)
        return(HYPHY20G_ERR_INCOMPATIBLE_DEVICE);

    /* argument checking */
    if (slice > HYPHY20G_LSCI_NUM_SLICE - 1) {
        return HYPHY20G_ERR_INVALID_ARG;
    }

    addr = HYPHY20G_LSCI_ENET_FEGE_L1RPP_REG_MII_CTL;
    addr = HYPHY20G_LSCI_MTSB_SLICE_REG_OFFSET(addr, slice);
    anEnblOff = HYPHY20G_LSCI_ENET_FEGE_L1RPP_BIT_MII_CTL_AN_ENABLE_OFF;
    anRstOff = HYPHY20G_LSCI_ENET_FEGE_L1RPP_BIT_MII_CTL_AN_RESTART_OFF;
    anRstMsk = HYPHY20G_LSCI_ENET_FEGE_L1RPP_BIT_MII_CTL_AN_RESTART_MSK;

    /* read out AN_ENABLE value */
    result = sysHyPhy20gBitRead(fileHndl, addr, anEnblOff, &anEnblVal);
    if(result) return result;

    /* ensure AN_ENABLE is b'1 at first */
    if (anEnblVal == 0) {
        return HYPHY20G_ERR_INVALID_PRECONFIG;
    }

    /* enable AN_RESTART bit to restart auto-negotiation */
    result = sysHyPhy20gBitWrite(fileHndl, addr, anRstOff, 1);
    if(result) return result;

    /* Poll register bit to make sure bit is cleared */
    result = sysHyPhy20gPollBit(fileHndl, addr, anRstMsk, 0, 1);
    if (result) return result;

    return HYPHY20G_SUCCESS;
} /* hyPhy20gLsciGeReAutoNeg */


/*******************************************************************************
**
**  hyPhy20gLsciGeAnBasePageCfg
**  ___________________________________________________________________________
**
**  DESCRIPTION:    This function configures remote and pause capability
**                  encoding in the auto-negotiation ADVERTISEMENT
**                  register (base page). Changes of base page register will
**                  be exchanged during renegotiation.
**
**                  It is user's responsibility to ensure this function is only
**                  used in GE MAC Terminated mode and auto-negotiation is
**                  enabled.
**
**                  Refer to IEEE 802.3 2000 clause 28 for details of the
**                  base page register fields.
**
**                  Refer to IEEE 802.3 2000 Annex 28B for details of remote
**                  fault and pause capability encoding.
**
**                  It is the user's responsibility to resolute pause
**                  capability according to IEEE 802.3 2000 Table 28B-3.
**
**                  This function can be used in two scenarios:
**                  1) call this function to initialize local device
**                  pause capability after calling hyPhy20gLsciInit
**                  but piror to call hyPhy20gLsciFeGeModeCfg;
**                  'reNegFlg' parameter must be b'0 in this case.
**
**                  2) dynamically call this function to change Remote fault
**                  and pause capability setting after hyPhy20gLsciFeGeModeCfg
**                  called;
**                  User may optionally restart the auto-negotiation by
**                  setting 'reNegFlg' parameter to b'1.
**
**  INPUTS:         fileHndl  - device handle
**                  slice     - LSCI slice processing resource
**                              slice number 0 - 15
**                  remoteFlt - Remote fault
**                              0 - No error, link OK
**                              1 - Link Failure
**                              2 - Offline
**                              3 - Auto-Negotiation_Error
**                              default value is b'00;
**                  pauseVal  - pause capability of local device
**                              0 - No pause
**                              1 - Symmetric PAUSE
**                              2 - Asymmetric PAUSE towardlink partner
**                              3 - Both Symmetric PAUSE and Asymmetric PAUSE
**                                  toward local device
**                              device default value is b'00;
**                  reNegFlg  - whether restart the auto-negotiation
**                              0 - don't renegotiation
**                              1 - renegotiation
**
**  OUTPUTS:        None       - None
**
**  RETURNS:        HYPHY20G_ERR_INCOMPATIBLE_DEVICE
**                  HYPHY20G_ERR_INVALID_ARG
**                  HYPHY20G_ERR_DEV_ACCESS
**                  HYPHY20G_ERR_INVALID_PRECONFIG
**                  HYPHY20G_ERR_POLL_TIMEOUT
**                  HYPHY20G_SUCCESS
**
*******************************************************************************/
INT4 hyPhy20gLsciGeAnBasePageCfg(struct file *fileHndl, UINT4 slice,
                                 UINT4 remoteFlt, UINT4 pauseVal,
                                 UINT4 reNegFlg)
{
    INT4 result;
    UINT4 basePgAddr;
    UINT4 remoteFltMsk;
    UINT4 pauseMsk;
    UINT4 regData;
    UINT4 devId, revId, status;
	
    /* Return error if API called against META device */
    result = hyPhy20gCheckRealRev(fileHndl, &devId, &revId, &status);
    if(result) return result;

    if (devId == HYPHY20G_META20G_DEVICE)
        return(HYPHY20G_ERR_INCOMPATIBLE_DEVICE);

    /* argument checking */
    if (slice > HYPHY20G_LSCI_NUM_SLICE - 1 ||
        remoteFlt > 3   ||
        pauseVal > 3    ||
        reNegFlg > 1) {
        return HYPHY20G_ERR_INVALID_ARG;
    }

    basePgAddr   = HYPHY20G_LSCI_ENET_FEGE_L1RPP_REG_MII_AUTO_NEG_AD;
    basePgAddr   = HYPHY20G_LSCI_MTSB_SLICE_REG_OFFSET(basePgAddr, slice);
    remoteFltMsk = HYPHY20G_LSCI_ENET_FEGE_L1RPP_BIT_MII_AUTO_NEG_AD_RF_MSK;
    pauseMsk     = HYPHY20G_LSCI_ENET_FEGE_L1RPP_BIT_MII_AUTO_NEG_AD_PS_MSK;

    /* configure  MII AUTO-NEGOTIATION ADVERTISEMENT register (base page) */
    result = sysHyPhy20gRead(fileHndl, basePgAddr, &regData);
    if(result) return result;

    result = hyPhy20gVarFieldWrite (&regData, remoteFltMsk, remoteFlt);
    if(result) return result;

    result = hyPhy20gVarFieldWrite (&regData, pauseMsk, pauseVal);
    if(result) return result;

    result = sysHyPhy20gWrite(fileHndl, basePgAddr, regData);
    if(result) return result;

    if (reNegFlg) {
        result = hyPhy20gLsciGeReAutoNeg(fileHndl, slice);
        if(result) return result;
    }

    return HYPHY20G_SUCCESS;

} /* hyPhy20gLsciGeAnBasePageCfg */


/*******************************************************************************
**
**  hyPhy20gLsciGeAnModeUpdate
**  ___________________________________________________________________________
**
**  DESCRIPTION:    This function dynamically configures auto-negotiation
**                  modes when the LSCI is configured in GE MAC Terminated mode.
**
**                  For GE MAC Terminated mode, user can select:
**                      - disable auto-negotiation feature;
**                      - enable auto-negotiation and only exchange base page;
**                      - enable auto-negotiation and exchange both base page
**                        and next page.
**
**                  It is the user's responsibility to call this function
**                  after calling hyPhy20gLsciFeGeModeCfg.
**
**                  It is the user's responsibility to ensure using this
**                  function only when LSCI configured in GE MAC Terminated
**                  mode.
**
**
**  INPUTS:         fileHndl  - device handle
**                  slice     - LSCI slice processing resource
**                              slice number 0 - 15
**                  anMode    - Operation mode of LSCI slice level
**                              0 - GE MAC Terminated - auto-negotiation
**                                  enabled, with base page exchange only;
**                              4 - GE MAC Terminated - auto-negotiation
**                                  disabled;
**                              5 - GE MAC Terminated - auto-negotiation
**                                  enabled, with next page exchange;
**
**  OUTPUTS:        None       - None
**
**  RETURNS:        HYPHY20G_ERR_INCOMPATIBLE_DEVICE
**                  HYPHY20G_ERR_INVALID_ARG
**                  HYPHY20G_SUCCESS
**                  HYPHY20G_ERR_NULL_PTR_PASSED
**                  HYPHY20G_ERR_INVALID_MODE
**                  HYPHY20G_ERR_INVALID_PRECONFIG
**                  HYPHY20G_ERR_DEV_ACCESS
**                  HYPHY20G_ERR_POLL_TIMEOUT
**
*******************************************************************************/
INT4 hyPhy20gLsciGeAnModeUpdate(struct file *fileHndl, UINT4 slice,
                                UINT4 anMode)
{
    INT4 result;
    UINT4 traffic;
    UINT4 addr;
    UINT4 bitOff;
    UINT4 msk;
    UINT4 anEnblVal;
    UINT4 locNextPgVal;
    UINT4 regData;

    /* argument checking */
    if (slice > HYPHY20G_LSCI_NUM_SLICE - 1 ||
        (anMode != LSCI_GE_MAC_TEMINATION &&
         anMode != LSCI_GE_MAC_TEMINATION_AN_DISABLE &&
         anMode != LSCI_GE_MAC_TEMINATION_AN_NEXTPG)) {
        DBG_PRINT("%s, %s, %d, HYPHY20G_ERR_INVALID_ARG\n",__FILE__, __FUNCTION__, __LINE__);
        return HYPHY20G_ERR_INVALID_ARG;
    }

    /* retrieve slice mode from context */
    result = lsciHyPhy20gLsciCtxtGetMode(fileHndl, slice, &traffic);
    if(result) return result;

    /* confirm mode before processing */
    if (traffic != LSCI_MAC_TEMINATION) {
        return HYPHY20G_ERR_INVALID_PRECONFIG;
    }

    /*
     * init configuration values
     */
    switch (anMode) {
        case LSCI_GE_MAC_TEMINATION:
            anEnblVal    = 1;
            locNextPgVal = 0;
            break;
        case LSCI_GE_MAC_TEMINATION_AN_DISABLE:
            anEnblVal    = 0;
            locNextPgVal = 0;
            break;
        case LSCI_GE_MAC_TEMINATION_AN_NEXTPG:
            anEnblVal    = 1;
            locNextPgVal = 1;
            break;
        default:
            DBG_PRINT("%s, %s, %d, HYPHY20G_ERR_INVALID_ARG\n",__FILE__, __FUNCTION__, __LINE__);
            return HYPHY20G_ERR_INVALID_ARG;
    }

    /* enable/disable the Auto-Negotiation feature */
    addr = HYPHY20G_LSCI_ENET_FEGE_L1RPP_REG_MII_CTL;
    addr = HYPHY20G_LSCI_MTSB_SLICE_REG_OFFSET(addr, slice);
    bitOff = HYPHY20G_LSCI_ENET_FEGE_L1RPP_BIT_MII_CTL_AN_ENABLE_OFF;
    result = sysHyPhy20gBitWrite(fileHndl, addr, bitOff, anEnblVal);
    if(result) return result;

    if (anEnblVal) {
        /* configure MII AUTO-NEGOTIATION ADVERTISEMENT register (base page) */
        addr = HYPHY20G_LSCI_ENET_FEGE_L1RPP_REG_MII_AUTO_NEG_AD;
        addr = HYPHY20G_LSCI_MTSB_SLICE_REG_OFFSET(addr, slice);
        regData = 0x0000;

        if (anMode == LSCI_GE_MAC_TEMINATION ||
            anMode == LSCI_GE_MAC_TEMINATION_AN_NEXTPG) {

            msk = HYPHY20G_LSCI_ENET_FEGE_L1RPP_BIT_MII_AUTO_NEG_AD_NEXT_PAGE_MSK;
            result = hyPhy20gVarFieldWrite(&regData, msk, locNextPgVal);
            if(result) return result;

            msk = HYPHY20G_LSCI_ENET_FEGE_L1RPP_BIT_MII_AUTO_NEG_AD_HALF_DUPLEX_MSK;
            result = hyPhy20gVarFieldWrite(&regData, msk, 0);
            if(result) return result;

            msk = HYPHY20G_LSCI_ENET_FEGE_L1RPP_BIT_MII_AUTO_NEG_AD_FULL_DUPLEX_MSK;
            result = hyPhy20gVarFieldWrite(&regData, msk, 1);
            if(result) return result;
        }

        DBG_PRINT("%s, %s, %d, value 0x%x to write to base page register.\n",__FILE__, __FUNCTION__, __LINE__, (unsigned int)regData);

        result = sysHyPhy20gWrite(fileHndl, addr, regData);
        if(result) return result;

        /* load the base page setting to the core */
        addr = HYPHY20G_LSCI_ENET_FEGE_L1RPP_REG_CFG_AND_STAT;
        addr = HYPHY20G_LSCI_MTSB_SLICE_REG_OFFSET(addr, slice);
        msk = HYPHY20G_LSCI_ENET_FEGE_L1RPP_BIT_CFG_AND_STAT_AN_ABLTY_ADV_UPD_MSK;
        result = hyPhy20gRegFieldWrite(fileHndl, addr, msk, 1);
        if(result) return result;

        /* Wait for AN_ABLTY_ADV_UPD bit to self-cleared */
        result = sysHyPhy20gPollBit(fileHndl, addr, msk,
                                    0, HYPHY20G_DELAY_20USEC);
        if(result) return result;
    }

    return HYPHY20G_SUCCESS;

} /* hyPhy20gLsciGeAnModeUpdate */

/*******************************************************************************
**
**  hyPhy20gLsciUniDirEn
**  ___________________________________________________________________________
**
**  DESCRIPTION:    This function enables or disables the uni-direction
**                  mode that allows the receive and transmit paths of
**                  Ethernet link to operate independently.
**
**                  It is user's responsibility to ensure this function is 
**                  used only in MAC Terminated mode.
**
**                  It is user's responsibility to ensure this function is
**                  called after calling hyPhy20gLsciInit.
**
**  INPUTS:         fileHndl  - device handle
**                  slice     - LSCI slice processing resource
**                              slice number 0 - 15
**                  enbl      - enables or disables uni-direction mode
**                              0 - disable
**                              1 - enable
**
**  OUTPUTS:        None       - None
**
**  RETURNS:
**                  HYPHY20G_ERR_INVALID_ARG
**                  HYPHY20G_ERR_DEV_ACCESS
**                  HYPHY20G_SUCCESS
**
*******************************************************************************/
INT4 hyPhy20gLsciUniDirEn(struct file *fileHndl, UINT4 slice, UINT4 enbl)
{
    INT4 result;
    UINT4 addr;
    UINT4 msk;

    /* argument checking */
    if (slice > HYPHY20G_LSCI_NUM_SLICE - 1 ||
        enbl > 1) {
        return HYPHY20G_ERR_INVALID_ARG;
    }

    addr = HYPHY20G_LSCI_ENET_FEGE_TOP_REG_MD_CFG;
    addr = HYPHY20G_LSCI_MTSB_SLICE_REG_OFFSET(addr, slice);
    msk  = HYPHY20G_LSCI_ENET_FEGE_TOP_BIT_MD_CFG_UNIDIRECTIONAL_MODE_MSK;

    result = hyPhy20gRegFieldWrite (fileHndl, addr, msk, enbl);
    if(result) return result;

    return HYPHY20G_SUCCESS;

} /* hyPhy20gLsciUniDirEn */

/*******************************************************************************
**
**  hyPhy20gLsciFeGePattCfg
**  ___________________________________________________________________________
**
**  DESCRIPTION:    This function configures PCS to send jitter pattern or
**                  a user-configured 10-bit pattern.
**
**                  CUS_PTRN should be set to 'b111111110 for the
**                  GE /V/ error pattern.
**                  CUS_PTRN should be set to either 'b111111100 or 'b011111100
**                  for the FE /H/ error pattern.
**
**                  This function is used for FE and GE modes.
**
**                  Alternatively, this function can be called to disable the
**                  pattern generation for normal operation.
**
**  INPUTS:         fileHndl   - device handle
**                  slice      - LSCI slice processing resource
**                               slice number 0 - 15
**                  dir        - data path direction
**                               0 - pattern generation in transmit direction
**                                   (from the CPB to the SFP)
**                               1 - pattern detection in receive direction
**                                   (from the SFP to the CPB)
**                  ptrnSel    - specifies a pattern type
**                               For the transmit direction (dir == 0): 
**                                0 - Normal Operation Mode
**                                1 - Inverting PRBS-11 pattern
**                                2 - Reserved
**                                3 - Reserved
**                                4 - Low Frequency random jitter Pattern
**                                5 - Mixed Frequency random jitter Pattern
**                                6 - High Frequency random jitter Pattern
**                                7 - Custom Pattern
**                               For the receive direction (dir == 1): 
**                                0 - Low Frequency random jitter Pattern
**                                1 - Mixed Frequency random jitter Pattern
**                                2 - High Frequency random jitter Pattern
**                                3 - Custom Pattern
**                                4 - Inverting PRBS-11 pattern
**                  ptrnVal    - custom pattern value.
**                               For the transmit direction (dir == 0), this 
**                               parameter must be a 9-bit value only when
**                               ptrnSel == 7; otherwise set it to 0.
**                               For the receive direction (dir == 1), this 
**                               parameter must be a 10-bit value only when
**                               ptrnSel == 3; otherwise set it to 0.
**
**  OUTPUTS:        None       - None
**
**  RETURNS:        HYPHY20G_ERR_INVALID_ARG
**                  HYPHY20G_ERR_DEV_ACCESS
**                  HYPHY20G_SUCCESS
**
*******************************************************************************/
INT4 hyPhy20gLsciFeGePattCfg(struct file *fileHndl, UINT4 slice, UINT4 dir,
                             UINT4 ptrnSel, UINT4 ptrnVal)
{
    INT4 result;
    UINT4 enblAddr;
    UINT4 enblOffset;
    UINT4 enblBitVal;
    UINT4 ptrnAddr;
    UINT4 ptrnSelMsk;
    UINT4 cusPtrnMsk;

    /* argument checking */
    if (slice > HYPHY20G_LSCI_NUM_SLICE - 1 ||
        dir > 1 || ptrnSel > 7) {
        return HYPHY20G_ERR_INVALID_ARG;
    }
    if ((dir == 1 && ptrnSel > 4) || 
        (dir == 0 && ptrnSel > 7) ||
        (dir == 1 && ptrnVal > 0x3FF) || 
        (dir == 0 && ptrnVal > 0x1FF)) {
        return HYPHY20G_ERR_INVALID_ARG;
    }

    if (dir) {
        /* L1RPP */
        ptrnAddr = HYPHY20G_LSCI_ENET_FEGE_L1RPP_REG_JTR_PAT_STAT_AND_CFG;
        ptrnAddr = HYPHY20G_LSCI_MTSB_SLICE_REG_OFFSET(ptrnAddr, slice);
        enblAddr = HYPHY20G_LSCI_ENET_FEGE_L1RPP_REG_CFG_AND_STAT;
        enblAddr = HYPHY20G_LSCI_MTSB_SLICE_REG_OFFSET(enblAddr, slice);

        enblOffset = HYPHY20G_LSCI_ENET_FEGE_L1RPP_BIT_CFG_AND_STAT_L1RPP_EN_OFF;
        ptrnSelMsk = HYPHY20G_LSCI_ENET_FEGE_L1RPP_BIT_JTR_PAT_STAT_AND_CFG_PTRN_SEL_MSK;
        cusPtrnMsk = HYPHY20G_LSCI_ENET_FEGE_L1RPP_BIT_JTR_PAT_STAT_AND_CFG_CUS_PTRN_MSK;
    } else {
        /* L1TPP */
        ptrnAddr = HYPHY20G_LSCI_ENET_FEGE_L1TPP_REG_JTR_PAT_GEN;
        ptrnAddr = HYPHY20G_LSCI_MTSB_SLICE_REG_OFFSET(ptrnAddr, slice);
        enblAddr = HYPHY20G_LSCI_ENET_FEGE_L1TPP_REG_CFG;
        enblAddr = HYPHY20G_LSCI_MTSB_SLICE_REG_OFFSET(enblAddr, slice);

        enblOffset = HYPHY20G_LSCI_ENET_FEGE_L1TPP_BIT_CFG_L1TPP_EN_OFF;
        ptrnSelMsk = HYPHY20G_LSCI_ENET_FEGE_L1TPP_BIT_JTR_PAT_GEN_PTRN_SEL_MSK;
        cusPtrnMsk = HYPHY20G_LSCI_ENET_FEGE_L1TPP_BIT_JTR_PAT_GEN_CUS_PTRN_MSK;
    }

    result = sysHyPhy20gBitRead(fileHndl, enblAddr, enblOffset, &enblBitVal);
    if(result) return result;

    /* disable L1TPP or L1RPP prior to pattern configuration */
    if (enblBitVal) {
        result = sysHyPhy20gBitWrite(fileHndl, enblAddr, enblOffset, 0);
        if(result) return result;
    }

    if (dir) {
        UINT4 selVal;
        UINT4 fegeMdVal;
        UINT4 modeAddr;
        UINT4 modeMsk;
        UINT4 cdAddr;

        cdAddr = HYPHY20G_LSCI_ENET_FEGE_L1RPP_REG_COMMA_DET;
        cdAddr = HYPHY20G_LSCI_MTSB_SLICE_REG_OFFSET(cdAddr, slice);
        
        modeAddr = HYPHY20G_LSCI_ENET_FEGE_TOP_REG_MD_CFG;
        modeAddr = HYPHY20G_LSCI_MTSB_SLICE_REG_OFFSET(modeAddr, slice);
        modeMsk  = HYPHY20G_LSCI_ENET_FEGE_TOP_BIT_MD_CFG_FEGE_MODE_MSK;
        result = hyPhy20gRegFieldRead(fileHndl, modeAddr, modeMsk, &fegeMdVal);
        if(result) return result;
    
        if (fegeMdVal == 1 && ptrnSel == 4) {
            selVal = 1;
        } else {
            selVal = 0;
        }

        result = sysHyPhy20gBitWrite(fileHndl, cdAddr, 0, selVal);
        if(result) return result;
    }

    if ((dir == 0 && ptrnSel == 7) || (dir == 1 && ptrnSel == 3)) {
        result = hyPhy20gRegFieldWrite(fileHndl, ptrnAddr, cusPtrnMsk, ptrnVal);
        if(result) return result;
    }

    if (!(dir == 1 && ptrnSel == 4)) {
        result = hyPhy20gRegFieldWrite(fileHndl, ptrnAddr, ptrnSelMsk, ptrnSel);
        if(result) return result;
    }

    /* enable L1TPP or L1RPP */
    if (enblBitVal) {
        result = sysHyPhy20gBitWrite(fileHndl, enblAddr, enblOffset, 1);
        if(result) return result;
    }

    return HYPHY20G_SUCCESS;

} /* hyPhy20gLsciFeGePattCfg */

/******************************************************************************/
/* PRIVATE FUNCTIONS                                                          */
/******************************************************************************/


/* end of file */
